{"componentChunkName":"component---src-templates-reading-template-js","path":"/reading/readableCode-02_consideration","result":{"data":{"markdownRemark":{"html":"<h2>コードの思いやり</h2>\n<p>リーダブルコードの目的である</p>\n<p><strong>HTML・コードは他の人が最短時間で理解できるように書かなければならない</strong></p>\n<p>を達成するために、コードの「思いやり」について説明していきます</p>\n<h2>1 度に 1 つのことをする</h2>\n<p>ブラウザ上にトランプのデザインを実装しました。</p>\n<pre><code class=\"language-HTML\">&#x3C;ul class=\"cards\">\n    &#x3C;li class=\"spade\">3&#x3C;/li>\n    &#x3C;li class=\"heart\">A&#x3C;/li>\n    &#x3C;li class=\"clover\">J&#x3C;/li>\n&#x3C;/ul>\n</code></pre>\n<pre><code class=\"language-CSS\">.cards {\n    display: flex;\n}\n.cards .spade {\n    margin-right: 10px;\n    border: 1px solid #000;\n    border-radias: 15px;\n    background-color: #eee;\n}\n.cards .heart {\n    margin-right: 10px;\n    border: 1px solid #f00;\n    ...\n}\n.cards .clover { ... }\n</code></pre>\n<p>上記のように基本の中身をコピペで CSS を書いた場合「角のカーブをもっと小さくしたい」などのデザイン修正がはいった場合に全てのクラスへ修正が発生します</p>\n<p>コピペしたことが原因ではありません。「基本デザイン」「個別デザイン」を１つの CSS セレクタで実装したことが原因です</p>\n<p>次に「基本デザイン」「個別デザイン」を分割した CSS 設計で実装しました</p>\n<pre><code class=\"language-HTML\">&#x3C;ul class=\"cards\">\n    &#x3C;li class=\"card_item card_item-spade\">3&#x3C;/li>\n    &#x3C;li class=\"card_item card_item-heart\">A&#x3C;/li>\n    &#x3C;li class=\"card_item card_item-clover\">J&#x3C;/li>\n&#x3C;/ul>\n</code></pre>\n<pre><code class=\"language-CSS\">.cards {\n    display: flex;\n}\n.cards .card_item {\n    margin-right: 10px;\n    border-radias: 15px;\n    border: 1px solid #fff; /* 初期値 */\n    background-color: #fff; /* 初期値 */\n}\n.cards .card_item-spade {\n    border: 1px solid #000;\n    background-color: #eee;\n}\n.cards .card_item-heart { ... }\n.cards .card_item-clover { ... }\n</code></pre>\n<p>この CSS なら「card<em>item => 基本デザイン」「card</em>item-〇〇 => 個別デザイン」が分離していてメンテナンスが簡単になりました</p>\n<p>1 つの役割に沢山の機能が含まれる、1：多の CSS・コードは破綻しやすいです。それより 1：1 に保つ方が他人が読んでも理解しやすく、メンテナンスもしやすいです<br>\n※ただし分割しすぎると多：1 の関係になるので注意が必要</p>\n<h2>役割を明確に説明する</h2>\n<p>先程は CSS を「基本デザイン」「個別デザイン」に分けました。十分メンテナンスはしやすくなりましたが、さらに踏み込んで「役割」で分割します</p>\n<pre><code class=\"language-HTML\">&#x3C;ul class=\"l-container-12\">\n    &#x3C;li class=\"l-grid-4\">\n        &#x3C;div class=\"card card-spade\">\n            &#x3C;p class=\"card-text\">3&#x3C;/p>\n        &#x3C;/div>\n    &#x3C;/li>\n    &#x3C;li class=\"l-grid-4\">\n        &#x3C;div class=\"card card-heart\">\n            &#x3C;p class=\"card-text\">A&#x3C;/p>\n        &#x3C;/div>\n    &#x3C;/li>\n    &#x3C;li class=\"l-grid-4\">\n        &#x3C;div class=\"card card-clover\">\n            &#x3C;p class=\"card-text\">J&#x3C;/p>\n        &#x3C;/div>\n    &#x3C;/li>\n&#x3C;/ul>\n</code></pre>\n<p>役割で分割することで「l-container-12 => グリッドデザイン用のラッパー」など、「各クラスが何のために存在しているか」を一言で説明できるようになりました<br>\n※しかし先ほど述べた通り、分割したことによって更に HTML への負荷が上がりました。どのレベルまで分割するか案件やサイト規模を考慮して、どの CSS 設計を選択するか判断してください</p>\n<p>また CSS だけでなく、JavaScript で機能を実装しているときにも必ず 1 つの目的があります。目的を言葉で説明できない状態、説明以外のことをしている状態を避けましょう</p>\n<p>設問：タブ機能を実装した JavaScript をリファクタリングしてください。必要な動作は下記です</p>\n<ul>\n<li>クリックされたときにタブが開いていた場合、全て閉じる</li>\n<li>クリックされたタブのコンテンツを開く</li>\n</ul>\n<pre><code class=\"language-HTML\">&#x3C;ul>\n    &#x3C;li class=\"tabs js-openTab\" onClick=\"openTab(this, 'content1')\">tab1&#x3C;/li>\n    &#x3C;li class=\"tabs\" onClick=\"openTab(this, 'content2')\">tab2&#x3C;/li>\n    ...\n&#x3C;/ul>\n\n&#x3C;div class=\"contentWrap\">\n    &#x3C;div id=\"content1\" class=\"content\">...&#x3C;/div>\n    &#x3C;div id=\"content2\" class=\"content\">...&#x3C;/div>\n    ...\n&#x3C;/div>\n</code></pre>\n<pre><code class=\"language-JavaScript\">const openTab = function (currentTab, targetID) {\n    const tabElement = document.querySelectorAll('.tabs');\n    tabElement.forEach((tab) => {\n       tab.classList.remove('js-openTab');\n    });\n    const contentElement = document.querySelectorAll('.content');\n    contentElement.forEach((content) => {\n        content.classList.remove('js-openContent');\n    });\n\n    currentTab.classList.add('js-openTab');\n\n    const targetContent = document.getElementById(targetID);\n    targetContent.classList.add('js-openContent');\n};\n</code></pre>\n<h2>ライブラリを知る</h2>\n<p>ライブラリを知っていればもっと短く簡潔にかけます<br>\n普段から具現化系能力者のごとくライブラリに親しむことが大事です</p>\n<p>Before</p>\n<pre><code class=\"language-JavaScript\">const openTab = function (currentTab, targetID) {\n    const tabElement = document.querySelectorAll('.tabs');\n    tabElement.forEach((tab) => {\n        tab.classList.remove('js-openTab');\n    });\n    const contentElement = document.querySelectorAll('.content');\n    contentElement.forEach((content) => {\n        content.classList.remove('js-openContent');\n    });\n\n    currentTab.classList.add('js-openTab');\n\n    const targetContent = document.getElementById(targetID);\n    targetContent.classList.add('js-openContent');\n};\n</code></pre>\n<p>After</p>\n<pre><code class=\"language-JavaScript\">const openTab = function (currentTab, targetID) {\n    const $tabElement = $('.tabs');\n    $tabElement.removeClass('js-openTab');\n\n    const $contentElement = $('.content');\n    $contentElement.removeClass('js-openContent');\n\n    $(currentTab).addClass('js-openTab');\n\n    const $targetContent = $(targetID);\n    $targetContent.addClass('js-openContent');\n};\n</code></pre>\n<h2>短いコードを書く</h2>\n<p>コーダー・エンジニアが目指すべき、万人が読めるコードは「何も書かないこと」です</p>\n<pre><code class=\"language-JavaScript\">// やって欲しいことが何も書かなくても実行される\n</code></pre>\n<p>しかし残念なことに物理現象や保存則のせいで無から有はつくれません。できるだけ万人が読めるコードを目指して「短く」「簡単な」コーディングを行いましょう<br>\nまたブラウザの読み込みやレンダリングは早い方が体験が向上します。実際の案件でも短いコードを書けること、短いコードに変換できることは必須の技術です</p>\n<p>今後、読みやすいコーディングで心がけたいこととして下記を意識してください</p>\n<ul>\n<li>重複したコードを生み出さないために、汎用的で多目的に使えるコードを書く</li>\n<li>使われていないコードや役に立たない機能は削除する</li>\n</ul>\n<h2>まとめ</h2>\n<p>少し言語特性によった内容になりましたが、本ドキュメントで伝えたいことは下記です。意識しなくても実行できる状態を目指しましょう</p>\n<ul>\n<li>1 つの処理は 1 つのことだけをする</li>\n<li>ライブラリを知る</li>\n<li>短くコードを書く（コードを役割で分割する）</li>\n</ul>","frontmatter":{"date":"2000-01-02","title":"readableCode-コードの思いやり"}}},"pageContext":{"slug":"/reading/readableCode-02_consideration"}},"staticQueryHashes":["3649515864","63159454"]}